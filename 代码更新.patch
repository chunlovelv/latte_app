Index: src/main/java/com/example/javamanythreadsproject/day03/Demo06.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/example/javamanythreadsproject/day03/Demo06.java	(revision 16)
+++ src/main/java/com/example/javamanythreadsproject/day03/Demo06.java	(revision 16)
@@ -0,0 +1,37 @@
+package com.example.javamanythreadsproject.day03;
+
+import org.reactivestreams.Publisher;
+
+import java.io.File;
+
+import io.reactivex.Flowable;
+import io.reactivex.Observable;
+import io.reactivex.functions.Consumer;
+import io.reactivex.functions.Function;
+
+/**
+ * 作者: 李纯
+ * 时间: 2018/6/13
+ * 说明: rxjava使用
+ */
+public class Demo06 {
+
+    public static void main(String[] args) {
+        Flowable.just("加油，自信。。。").subscribe(new Consumer<String>() {
+            @Override
+            public void accept(String s) throws Exception {
+                System.out.println(s);
+            }
+        });
+        File file = new File("C:/Users/john/source/python/demo/demo1/demo1/2016-2017");
+        Flowable.fromArray(file.listFiles())
+                .subscribe(new Consumer<Object>() {
+                    @Override
+                    public void accept(Object o) throws Exception {
+                        System.out.println(o.getClass());
+                    }
+                });
+
+
+    }
+}
Index: src/main/java/com/example/javamanythreadsproject/day03/Demo02.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/example/javamanythreadsproject/day03/Demo02.java	(revision 16)
+++ src/main/java/com/example/javamanythreadsproject/day03/Demo02.java	(revision 16)
@@ -0,0 +1,136 @@
+package com.example.javamanythreadsproject.day03;
+
+import com.example.javamanythreadsproject.utils.DataUtil;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * 作者: 李纯
+ * 时间: 2018/6/8
+ * 说明: 多线程操作同一个文件
+ */
+public class Demo02 {
+
+    volatile  public static boolean isReady = false;
+
+    public static void main(String[] args) {
+        LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<>();
+        for(int j = 0;j<10;j++){
+            queue.offer("item" +j);
+        }
+        System.out.println(queue);
+        while (!queue.isEmpty()){
+            System.out.println(queue.poll());
+        }
+//        File file = new File("t.txt");
+//        for(int i = 0; i< 20;i++){
+//            FileThread ft = new FileThread(file);
+//            FileThread2 ft2 = new FileThread2(file);
+//            ft.start();
+//            ft2.start();
+//        }
+//
+//        ExecutorService executorService = Executors.newSingleThreadExecutor();
+//        executorService.execute(new Runnable() {
+//            @Override
+//            public void run() {
+//
+//            }
+//        });
+
+
+
+//        testIPuls();
+    }
+
+    private static void testIPuls() {
+        AtomicInteger atomicInteger = new AtomicInteger(0);
+        System.out.println(DataUtil.getCurrentTime());
+        for(int i= 0; i<100000000;i++){
+            atomicInteger.incrementAndGet();
+        }
+        System.out.println(atomicInteger.get());
+        System.out.println(DataUtil.getCurrentTime());
+        System.out.println();
+        System.out.println(DataUtil.getCurrentTime());
+        for(int i= 0; i<100000000;i++){
+            add();
+        }
+        System.out.println(i);
+        System.out.println(DataUtil.getCurrentTime());
+    }
+
+    public static volatile int i=0;
+    synchronized public static void add(){
+        i++;
+    }
+
+    static class FileThread extends Thread {
+        private final File file;
+        public FileThread(File file) {
+            this.file = file;
+        }
+
+        @Override
+        public void run() {
+            try {
+                synchronized (file) {
+                    OutputStream os = new FileOutputStream(file,true);
+                    while (isReady) {
+                        file.wait();
+                    }
+                    System.out.println("FileThread写入了数据");
+                    Thread.sleep(1000);
+                    os.write("111\n".getBytes());
+                    os.flush();
+
+                    file.notifyAll();
+                    isReady = true;
+                    os.close();
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+            } finally {
+            }
+        }
+    }
+
+
+    static class FileThread2 extends Thread {
+        volatile File file;
+        public FileThread2(File file){
+            this.file = file;
+        }
+        @Override
+        public void run() {
+            try {
+                synchronized (file){
+                    OutputStream os = new FileOutputStream(file,true);
+                    while (!isReady) {
+                        file.wait();
+                    }
+
+                    System.out.println("FileThread2写入了数据");
+                    Thread.sleep(1000);
+                    os.write("222\n".getBytes());
+                    os.flush();
+
+                    file.notifyAll();
+                    isReady = false;
+                    os.close();
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+            } finally {
+            }
+        }
+    }
+}
Index: src/main/java/com/example/javamanythreadsproject/day03/Demo03.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/example/javamanythreadsproject/day03/Demo03.java	(revision 16)
+++ src/main/java/com/example/javamanythreadsproject/day03/Demo03.java	(revision 16)
@@ -0,0 +1,116 @@
+package com.example.javamanythreadsproject.day03;
+
+import java.util.Arrays;
+import java.util.SortedMap;
+
+/**
+ * 作者: 李纯
+ * 时间: 2018/6/11
+ * 说明: 快速排序实现
+ */
+public class Demo03 {
+    public static void main(String[] args) {
+        int[] arr = {10, 2, 3, 8, 1, 0, 4, 9,3,2};
+//        quickSort2(arr);
+        selectSort(arr);
+        System.out.println(Arrays.toString(arr));
+    }
+
+    /**
+     * 选择排序
+     *
+     * @param arr
+     */
+    public static void selectSort(int[] arr) {
+        for (int i = 0; i < arr.length; i++) {
+            int k = i;
+            for (int j = k + 1; j < arr.length; j++) {
+                if (arr[k] >= arr[j]){
+                    k = j;
+                }
+            }
+            if(k >i){
+                int temp = arr[i];
+                arr[i] = arr[k];
+                arr[k] = temp;
+            }
+        }
+    }
+
+    public static void quickSort2(int[] arr) {
+        sort2(arr, 0, arr.length - 1);
+    }
+
+    public static void quickSort(int[] arr) {
+        sort(arr, 0, arr.length - 1);
+    }
+
+    /**
+     * @param arr
+     * @param high
+     * @param low
+     * @deprecated 快速排序核心代码
+     * 1.找到标准值来进行比较大小，从右面开始寻找比标准值小的值(直到找到为止)
+     * 2.从左边开始寻找比标准值大的值（直到找到为止）
+     * 3.将找到的两个值进行换位，然后继续步骤1，2
+     */
+    private static void sort(int[] arr, int low, int high) {
+        if (low > high) return;//递归结束条件
+        int temp_high = high,
+                temp_low = low,
+                temp_data = arr[temp_low],
+                t = 0;
+
+        while (temp_low < temp_high) {
+            //从数组的最右面开始找到比标准值小的值
+            while ((temp_low < temp_high) && arr[temp_high] >= temp_data) {
+                temp_high--;
+            }
+
+            //从数组的最左边开始找到比标准值大的值
+            while ((temp_low < temp_high) && arr[temp_low] <= temp_data) {
+                temp_low++;
+            }
+            //交换数据(只有当temp_low<temp_high时，条件才触发)
+            if (temp_low < temp_high) {
+                t = arr[temp_low];
+                arr[temp_low] = arr[temp_high];
+                arr[temp_high] = t;
+            }
+        }
+
+        //
+        arr[low] = arr[temp_low];
+        arr[temp_low] = temp_data;
+
+        sort(arr, low, temp_high - 1);
+        sort(arr, temp_high + 1, high);
+
+    }
+
+
+    private static void sort2(int[] arr, int low, int high) {
+        if (low > high) return;
+
+        int i = low, j = high, temp_data = arr[low], tmp = 0;
+        while (i < j) {
+            while (i < j && arr[j] >= temp_data) {
+                j--;
+            }
+
+            while (i < j && arr[i] <= temp_data) {
+                i++;
+            }
+
+            if (i < j) {
+                tmp = arr[i];
+                arr[i] = arr[j];
+                arr[j] = tmp;
+            }
+        }
+        arr[low] = arr[i];
+        arr[i] = temp_data;
+        sort2(arr, low, j - 1);
+        sort2(arr, j + 1, high);
+    }
+}
Index: src/main/java/com/example/javamanythreadsproject/day03/Demo04.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/example/javamanythreadsproject/day03/Demo04.java	(revision 16)
+++ src/main/java/com/example/javamanythreadsproject/day03/Demo04.java	(revision 16)
@@ -0,0 +1,90 @@
+package com.example.javamanythreadsproject.day03;
+
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.security.KeyPair;
+import java.security.KeyPairGenerator;
+import java.security.NoSuchAlgorithmException;
+import java.security.SecureRandom;
+import java.util.Base64;
+
+/**
+ * 作者: 李纯
+ * 时间: 2018/6/12
+ * 说明: 数据加密练习
+ */
+public class Demo04 {
+    public static final String pulicKey = "";
+    public static final String privateKey = "";
+    private static final String RSA = "RSA";
+    private static final String KEY_PAIR_PATH = "keypair.txt";
+
+    public static void main(String[] args) {
+//        KeyPair keyPair = getKeyPair();
+//        PublicKey pulicK = keyPair.getPublic();
+//        PrivateKey privateK= keyPair.getPrivate();
+//        System.out.println("pulicK==> "+pulicK.getFormat());
+//        System.out.println("privateK==> "+privateK.getFormat());
+        String testString = "hello,world! I love this place!!!";
+        Base64.Decoder decoder = Base64.getDecoder();
+        Base64.Encoder encoder = Base64.getEncoder();
+        String encodeString = encoder.encodeToString(testString.getBytes());
+        System.out.println("encode==> "+ encodeString);
+        byte[] decode = decoder.decode(encodeString);
+        System.out.println("decode==> "+ new String(decode));
+    }
+
+
+    public static KeyPair getKeyPair() {
+        try {
+            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(RSA);
+            keyPairGenerator.initialize(1024, new SecureRandom());
+            KeyPair keyPair = keyPairGenerator.generateKeyPair();
+            saveKeyPair(keyPair);
+            return keyPair;
+        } catch (NoSuchAlgorithmException e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    public static KeyPair getKeyPairFromFile(){
+        try {
+            FileInputStream fis = new FileInputStream(KEY_PAIR_PATH);
+            ObjectInputStream ois = new ObjectInputStream(fis);
+            KeyPair result = (KeyPair) ois.readObject();
+            ois.close();
+            fis.close();
+            return result;
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        return null;
+    }
+
+    /**
+     * 保存keypair
+     *
+     * @param keyPair
+     */
+    private static void saveKeyPair(KeyPair keyPair) {
+        try {
+            FileOutputStream fos = new FileOutputStream(KEY_PAIR_PATH);
+            ObjectOutputStream oos = new ObjectOutputStream(fos);
+            oos.writeObject(keyPair);
+            fos.flush();
+            oos.flush();
+            fos.close();
+            oos.close();
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+}
Index: src/main/java/com/example/javamanythreadsproject/day03/Demo01.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/example/javamanythreadsproject/day03/Demo01.java	(revision 16)
+++ src/main/java/com/example/javamanythreadsproject/day03/Demo01.java	(revision 16)
@@ -0,0 +1,105 @@
+package com.example.javamanythreadsproject.day03;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.Set;
+import java.util.concurrent.locks.Condition;
+
+/**
+ * 作者: 李纯
+ * 时间: 2018/6/8
+ * 说明: java Collections工具包的使用与练习
+ */
+public class Demo01 {
+    public static void main(String[] args) {
+        List<Integer> list = new ArrayList();
+        for (int i = 0; i < 10; i++) {
+            list.add((int) (Math.random() * 100 + 1));
+        }
+        System.out.println("原始数据==> " + list);
+
+        //使用Collections排序
+        Collections.sort(list);
+        System.out.println("排序之后==> " + list);
+
+        System.out.println("最大元素==> "+Collections.max(list));
+        Collections.fill(list, 5);
+        System.out.println("填充元素==> "+ list);
+
+        //线程安全的集合
+        List<Integer> l = Collections.synchronizedList(new ArrayList<Integer>());
+//        Collections.synchronizedMap(new HashMap<>())
+    }
+
+
+    class MyMap<K,V> implements Map<K,V> {
+
+
+        @Override
+        public int size() {
+            return 0;
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return false;
+        }
+
+        @Override
+        public boolean containsKey(Object key) {
+            return false;
+        }
+
+        @Override
+        public boolean containsValue(Object value) {
+            return false;
+        }
+
+        @Override
+        public V get(Object key) {
+            return null;
+        }
+
+        @Override
+        public V put(K key, V value) {
+            return null;
+        }
+
+        @Override
+        public V remove(Object key) {
+            return null;
+        }
+
+        @Override
+        public void putAll(Map<? extends K, ? extends V> m) {
+
+        }
+
+        @Override
+        public void clear() {
+
+        }
+
+        @Override
+        public Set<K> keySet() {
+            return null;
+        }
+
+        @Override
+        public Collection<V> values() {
+            return null;
+        }
+
+        @Override
+        public Set<Entry<K, V>> entrySet() {
+            return null;
+        }
+    }
+
+}
Index: src/main/java/com/example/javamanythreadsproject/day03/Demo05.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/example/javamanythreadsproject/day03/Demo05.java	(revision 16)
+++ src/main/java/com/example/javamanythreadsproject/day03/Demo05.java	(revision 16)
@@ -0,0 +1,74 @@
+package com.example.javamanythreadsproject.day03;
+
+import java.util.Arrays;
+
+/**
+ * 作者: 李纯
+ * 时间: 2018/6/12
+ * 说明: 算法的问题==》
+ * 一个按升序排列好的数组int[] arry = {-5,-1,0,5,9,11,13,15,22,35,46},输入一个x，
+ * int x = 31，在数据中找出和为x的两个数，例如 9 + 22 = 31，要求算法的时间复杂度为O(n);
+ */
+public class Demo05 {
+
+    public static void main(String[] args) {
+        int[] arry = {-5, -1, 0, 5, 9, 11, 13, 15, 22, 35, 46};
+        findSum(arry, 31);
+        int[] arr = {10, 2, 3, 8, 1, 0, 4, 9,3,2};
+        quickSort(arr);
+        System.out.println(Arrays.toString(arr));
+    }
+
+    public static void findSum(int[] arr, int sum) {
+        int i = 0, j = arr.length - 1;
+        while (i < j && (arr[i] + arr[j] != sum)) {
+            if (arr[i] + arr[j] > sum) {
+                j--;
+            }
+            if (arr[i] + arr[j] < sum) {
+                i++;
+            }
+        }
+
+        System.out.println("arr[i]= " + arr[i] + ",arr[j]= " + arr[j]);
+    }
+
+
+    /**
+     * 快速排序
+     * @param arr
+     */
+    public static void quickSort(int arr[]) {
+        q_sort(arr, 0, arr.length - 1);
+    }
+
+    private static void q_sort(int[] arr, int low, int high) {
+        if (low > high) return;
+        int i = low, j = high, tmp_data = arr[low], tmp;
+
+        while (i<j){
+            //右边寻找比标准值小的值
+            while (i<j&&(arr[j] >= tmp_data)){
+                j--;
+            }
+
+            //左边寻找比标准值大的值
+            while(i<j&&(arr[i]<= tmp_data)){
+                i++;
+            }
+
+            if(i<j){
+                tmp = arr[i];
+                arr[i] = arr[j];
+                arr[j] = tmp;
+            }
+        }
+
+        arr[low] = arr[i];
+        arr[i] = tmp_data;
+
+        q_sort(arr, low, j-1);
+        q_sort(arr, j+1, high);
+    }
+
+}
Index: build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- build.gradle	(revision 15)
+++ build.gradle	(revision 16)
@@ -6,6 +6,7 @@
 
 dependencies {
     implementation fileTree(dir: 'libs', include: ['*.jar'])
+    api "io.reactivex.rxjava2:rxjava:2.1.14"
 }
 
 sourceCompatibility = "1.7"
Index: JavaManyThreadsProject.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- JavaManyThreadsProject.iml	(revision 15)
+++ JavaManyThreadsProject.iml	(revision 16)
@@ -27,5 +27,11 @@
     </content>
     <orderEntry type="inheritedJdk" />
     <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="library" exported="" scope="PROVIDED" name="rxjava-2.1.14" level="project" />
+    <orderEntry type="library" exported="" scope="PROVIDED" name="reactive-streams-1.0.2" level="project" />
+    <orderEntry type="library" exported="" scope="RUNTIME" name="rxjava-2.1.14" level="project" />
+    <orderEntry type="library" exported="" scope="RUNTIME" name="reactive-streams-1.0.2" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="rxjava-2.1.14" level="project" />
+    <orderEntry type="library" exported="" scope="TEST" name="reactive-streams-1.0.2" level="project" />
   </component>
 </module>
\ No newline at end of file
